








////      big thanks  to my supporters  who made this possible : captain crappy and mrs fever blister  Geno  Niji  BrokenWrd   Mythos  Supa Hot Fire Memz Matthew Minion   HARLEY GIRL   Mike and Mia G   Game Prime  jeremy  tobie moss   brian duncan   jets mess mess  mess  james chastain
// without your help none of this would exist.

// copyright 2021 Spayse Mc G  can be reproduced after 9/9/2022 without limitation


const options = {
  ReferrerPolicy: "same-origin", "allowUpgrades": 'true', "cross-origin": "true",
  transports: ['websocket', 'polling', 'jsonp', 'xhr',],
  pingTimeout: 90000,
  rejectUnauthorized: false,
  pingInterval: 5000,
  heartbeatInterval: 5 * 1000,
  httpCompression: " true",
  Connection: "Upgrade",
  origins: ['http://127.0.0.1:42042/Main ', "http://localhost:42042/reg"],
  Vary: 'Origin',
  extraHeaders: {
    AccessControlAllowOrigin: ['*:*',"*",'/foam', '/reg', "/wallet", "/post"],
    AccessControlAllowHeaders: "Content-Type"
  },
  Accept: '*:*',
  Connection: 'keep-alive'

}
////////////////////
////////////////////////////////
//////////////////////////////////////////////////////////////
//
const stripAnsi=require('strip-ansi')
const strip= stripAnsi
let leader
let text1=`aaabbbcccdddeeefffggghhhiiijjjkkklllmmmnoopqrstuvwxyz0000000000000000000000000000000000000000"nonce":0,"difficulty":3,"bubbles":[{"u":0,"n":0}],"mints":[]}]"nonce":0,"difficulty":3,"bubbles":[{"u":0,"n":0}],"mints":[]}]333333333333333333333222222222222222222222{"chain":[{"timestamp":"Genesis time","lastHash":"-----","hash":"f1r57-h45h","data":[],"nonce":0,"difficulty":3,"bubbles":[{"u":0,"n":0}],"mints":[]}]}2222222224444444444444444444445555555555555555555555555555555555555556666666666666666666666666666666666777777777777777777777777777777777777777777777777788888888888887777777777777777777777777777777777777777777777777776666666666666666666666666666666666666666888888999999999999999999998898979789758957564563453452342345345345w123123210000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000asdfghasdfghjasdfgcbcbcbcbcbcbcbcbcbcbcbcbcbabcdfgabcdefgabcdefgblock chain ,{},[]<:::,mnopquwtyfdhasldwghcbzmcvbvzsdl;wer;;;111111111111111ffffffffffffffffffffff()77774563214554788845500000000000000000000000000000000000000000000000000000000000()abcdefgeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeffefefeffefefefefefefefggggggggggggggggggg01234567aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaeeeeeeeeefffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`
let text2=`aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa999999999999999999999999ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff99999999999998888888888888788888888888888888888888888877777777777777777777777777777777777777777777777777777777777777777776666666666666666666666666666666666666666666666666666666655555555555555555555555555555555555555555555555555564544444444444444444444444444444444444444444444444444333333333333333333333333333333333222222222222222222222222222222222222221111111111111111111abcdreinmbxcm,.vZMXC>?v,blockinputjjdfk'gl;gtio0000000000000abcdefggfedcaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbccccccccccccccccccccccccccddddddddddddddddddddeeeeeeeeefffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeefffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9999999999080560756795r96459679753488509345803945898468396-590458609534985950345,,,,,,,,,{}{}{}{}{}{}{}{[][][][][][,,,,,,,,,,,,,::::::::::::::::::::::::0000012333330441jgdfgdfjghsdflkjhfnsxcbvhcbv000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111999999999`
let text3=`0900000000000000000000000000000000000000000000000000000000000000000000aaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbccccccccccccccccccccccccccddddddddddddddddddddeeeeeeeeefffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeefffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9999999999080560756795r96459679753488509345803945898468396-590458609534985950345,,,,,,,,,{}{}{}{}{}{}{}{[][][][][][,,,,,,,,,,,,,::::::::::::::::::::::::0000012{"chain":[{"timestamp":"Genesis time","lastHash":"-----","hash":"f1r57-h45h","data":[],"nonce":0,"difficulty":3,"bubbles":[{"u":0,"n":0}],"mints":[]}]}333330441jgdfgdfjghsdflkjhfnsxcbvhcbvksdjfskljfdf99999999999999999999999999999999999999999999999999999988888888888887888888888888888888888888888777777777777777777777777777777777777777777777777777777777777777777766666666666666666666666666666666666666666666666666666666555555555555555555555555555555555555555555555555555645444444444444444444444444444441111111111111111111111111111111111111111111111111111111111111111111111111114444444444444444444443333333333333333333333333333333332222222222222222222222222222229999999999999999999999999999999999999999999999999999999999999998978978978090667867757456456456453452343523454565456565675676787878978989789989098967876756656456000000000`
let text4=`1111111111ffffffffffffffffffffff()7777456321455478884550000000000000123456780000000000asdfghasdfghjasdfgcbc0000000000000000000000000000000000000()abcdefgeeeeeeeeeeeeeeee{"chain":[{"timestamp":"Genesis time","lastHash":"-----","hash":"f1r57-h45h","data":[],"nonce":0,"difficulty":3,"bubbles":[{"u":0,"n":0}],"mints":[]}]}eeeeeeeeeeeeeeeeeeeeinputoutput,,,,efefefeffefefeffefefefefefefefggggggggggggggggggg012345678900000000000000000000000000000000000000000000000000000000000000011111111111111111111111111111111111111111111111111111113333333333333333333333333333333333333333333332222222222222222222222222222224444444444444444444445555555555555555555555555555555555555556666666666666666666666666666666666777777777777777777777777777777777777777777777777788888888888887777777777777777777777777777777777777777777777777776666666666666666666666666666666666666666888888888888889999999999999999999999999999999999999998898979789758957564563453452342345345345w123123210000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000abcdefghijklmnopqrstuvwxyz9876543210gfedcbaabcdefg00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004444444444444444444444444444444444444444444444444444455555555555555555555555555555566666666666666666666677777777777777777777788888888809090990888888888`
let text5=`{"balance":lastHash"500return new this('Genesis time', '-----', 'f1r57-h45h', [],[{"u":0,"n":0}],[], 0, 0)  },"keyPair":{"ec":{"curve":{"type":"short","p":"ffffffff}f{}gffffffffffffff[]][*()ffffffffffGffffffffffffffffffffffefffffc2f","red":{"m":"fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffhghghghghghghfffffffffffffffdddddddddddddddddddddddddddddddddddddd111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000999999999999900000000000000000000000000000000000000000000000000000000000000000000000000000000000099999999999999999999999999999999999900000000000000000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaassssssssssssscccccccccccccccvvvvvvvvvzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzdddddddddddddddddddd00000000000000000000000000000000000000001111111111111111111111111111111111`
/////////////////////////////////////////////////////////h45h', [],[{"u":0,"n":0}],[], 0, 0)  },"keyPair":{"ec":{"curve":{"type":"short","p":"ffffffff}f{}gffffffffffffff[]][*()ffffffffffGffffffffffffffffffffffefffffc2f","red":{"m":"fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffhghghghghghghfffffffffffffffdddddddddddddddddddddddddddddddddddddd111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110000000000000000000999999999999900000000000000000000000000000000000000000000000000000000000000000000000000000000000099999999999999999999999999999999999900000000000000000000000000000000000000aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaassssssssssssscccccccccccccccvvvvvvvvvzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzdddddddddddddddddddd00000000000000000000000000000000000000001111111111111111111111111111111111`
//////////////////////////////////////////////////////////////////
let messnum = 0
let shortest =100000000
const express = require('express');
const app = express();
const http = require('http').Server(app)
const io = require('socket.io')(http, options)
const lerp=require('lerp');
const Game = require('./thegame')
let bubbletime = 1618878900000 - Date.now() / 1000 / 60 / 60 / 24
console.log('sockets loaded')
const HTTP_PORT = process.env.HTTP_PORT || 80
const bodyParser = require('body-parser');
const path = require('path')
const Blockchain = require('./blockchain');
const Wallet = require('./wallet');
const TP = require('./wallet/transaction-pool');
let blockchain = new Blockchain();
let tempoModulus = 0
let theEnd=0
const Client = require('socket.io-client')
const Clii = require('socket.io-client')
let wallet = new Wallet(blockchain);
let beginTime=-0.1 
let game
let mining=false
const Bubble = require('./bubble')
let tempChain=[]

const {Huffman} = require('huffman-ts')

const transactionPool = new TP();
const P2P_PORT = process.env.P2P_PORT || 80;;
const msocket = new Clii("http://localhost:80")
const Miner = require('./newminer');
const miner = new Miner(blockchain, transactionPool, wallet, msocket);
app.use(bodyParser.json());
console.log('Main body')
let fs = require('fs').promises;
//const Transaction = require('./wallet/transaction');
app.use(express.static('public'))
let peers=[]

let bubbles = []

let abubble = new Bubble()
////////////////////////////////////////////////////////

let user = require("./public/files/userData")
console.log (user)

const myList=require("./public/files/list") 
const Registry = require('./registry')
const registry=new Registry(myList)
app.get('/post', (req, res) => {

  app.use(express.static(path.join(__dirname, 'public/files/social')));

  res.sendFile(path.join(__dirname, 'index.html'));
});
app.get('/reg', (req, res) => {

  app.use(express.static(path.join(__dirname, 'public')));

  res.sendFile(path.join(__dirname, 'public/register.html'));
});


app.get('/', (req, res) => {
  app.use(express.static(path.join(__dirname, 'public')));

  res.sendFile(path.join(__dirname, 'public/index.html'));
});


const lists= registry.list 

for (let list of lists){
	

		
	     let lObject={
			"id": list.id,
			"ip": list.ip,
     "client" :new Client(list.ip , options)
		   		
		      }
		

	      peers.push(lObject)
		

	 
	}
    
  
   /* let myc=new Client("wss://74.83.219.74:42042",options)

 
    kline
    
     
      myc.emit("givechain", blockchain.replaceChain(blockchain.chain))
      myc.on("tx", (transaction) => {
        console.log("recieved tx      client")
        transactionPool.updateOrAddTransaction(transaction)
      })
      myc.on("broadcastTransaction", (transaction) => {
        console.log("recieved tx  ......client.")
    
        peer.client.emit("newTX", transaction)
    
      })
    
      myc.on("connect_error", (error) => {
        console.log("error",error)
      })
      myc.on("newUser", registry => {
    
        console.log("new user ", registry)
    
      })
      myc.emit("bubbles", bubbles)
      myc.on("bubbles", (bubbles) => {
    
        for (let bubble of bubbles) {
          let foam
          foam = bubble
          peer.client.emit("foaming", foam)
    
        }
    
      })
      myc.emit("chain", blockchain.chain)
      myc.emit("messnum", messnum)
      myc.on("newChain", (newChain)=>{
        console.log("newChainMessage", newChain)
  
        let block=newChain[newChain.length-1]
        let bLength= JSON.stringify(block.huff).length
        let game =new Game(newChain,beginTime,shortest,blockchain)
        let outKum
  
        if (bLength<shortest){
           
  
           outKum=game.outcome
  
          console.log( "outcome",outKum)
        }
        if (game.timeLeft<=0){beginTime=-0.1}
        
      })
  
    
*/
let mytx=[]
    function getMyTx(){

   let txs=[]
            
  let aChain=blockchain.decompHuff(blockchain.chain)
      aChain.forEach(block => block.data.forEach(transaction => {
       //console.log (transaction)

        txs.push(transaction);
      }))
      for (let i=0;i<txs.length;i++){
             let addy =  wallet.publicKey
              let  minp=txs[i].input.address
             //console.log  (minp)
                if  (addy>=minp ){
                      mytx.push(txs[i])
                //  console.log(mytx)
                     
                      return mytx
               }
 
          }
     
     }
    

     function checkTime(){

     let timeLeft = Date.now()-this.begin
      let  n = 20000-timeLeft
      return n
    }
     

///////////////////////////////////////////////////////////?????????????????????????????????????????????????????????????????????????????????????????

/////////////////////////////////////////////////////////////////////////                                            
console.log(registry)


console.log("user------> :",user )

///////////////////////////////////////////////////////////////////////////

////////////////////////
http.listen(HTTP_PORT, (socket) => console.log(`Listening on port ${HTTP_PORT} with id : go fuck yourself`))


let  updateUi= setInterval( kline,20000  )

 function  kline(){   io.emit("wallet", { "address": wallet.publicKey, "balance": wallet.calculateBalance(blockchain), "block": blockchain.chain.length,"tx":wallet.getTx(blockchain)})}
io.on('connection', (socket) => {
  console.log("a new client connected :",socket.conn.remoteaddress)
  io.on("bubbles", (bubbles) => {
    for (let bubble of bubbles) {
      let foam
      foam = bubble
      socket.emit("foaming", foam)

    }


  })


  io.on("foam",foam=>{

    socket.emit("foaming",foam)

  })



  io.setMaxListeners(50)
  socket.setMaxListeners(30)
  io.emit("BLOCKCHAIN", blockchain.chain)
  socket.emit("BLOCKCHAIN", blockchain.chain)
  socket.emit("bubbles", bubbles)
  io.emit("wallet", { "address": wallet.publicKey, "balance": wallet.calculateBalance(blockchain), "block": blockchain.chain.length,"tx": wallet.getTx(blockchain)})
  console.log("wallet", { "address": wallet.publicKey, "balance": wallet.calculateBalance(blockchain), "block": blockchain.chain.length })
updateUi



for (let peer of peers){
      
  console.log( "PEERS +++++ > :",peers)
  peer.client.on("BLOCKCHAIN", (chain) => {
    blockchain.replaceChain(chain)
    console.log('============================client')
    kline
    let file = {}
    file.name = "chain"
    file.data = JSON.stringify(blockchain)
    filehandler(file)
  })

 peer.client.on("connect",()=>{
  console.log("client",)
    blockchain.replaceChain(blockchain.chain)
kline

  })
  peer.client.emit("givechain", blockchain.replaceChain(blockchain.chain))
  peer.client.on("tx", (transaction) => {
    console.log("recieved tx      client")
    transactionPool.updateOrAddTransaction(transaction)
  })
  peer.client.on("broadcastTransaction", (transaction) => {
    console.log("recieved tx  ......client.")

    peer.client.emit("newTX", transaction)

  })

  peer.client.on("connect_error", (error) => {
    console.log("error",error.message)
  })
  peer.client.on("newUser", registry => {

    console.log("new user ", registry)

  })
  peer.client.emit("bubbles", bubbles)
  peer.client.on("bubbles", (bubbles) => {

    for (let bubble of bubbles) {
      let foam
      foam = bubble
      peer.client.emit("foaming", foam)

    }

  })
  peer.client.emit("chain", blockchain.chain)
  peer.client.emit("messnum", messnum)
  peer.client.on("newChain", (newChain)=>{
    console.log("newChainMessage", newChain)

    let block=newChain[newChain.length-1]
    let bLength= JSON.stringify(block.huff).length
    let game =new Game(newChain,beginTime,shortest,blockchain)
    let outKum

    if (bLength<shortest){
       

       outKum=game.outcome

      console.log( "outcome",outKum)
    }
    if (game.timeLeft<=0){beginTime=-0.1}
    
  })


}

socket.on("connect_error", (error) => {
  console.log("error",error)
})
 socket.on("BLOCKCHAIN", (chain) => {
    let file = {}
    file.name = "chain"
    file.data = JSON.stringify(blockchain.chain)

    console.log('recieved chain   SERVER')
    blockchain.replaceChain(chain)
    filehandler(file)
  })

for (let peer of peers){

peer.client.emit("BLOCKCHAIN",blockchain.chain)
console.log("sent chain")
}

  socket.emit("registrty", registry)
  socket.on("reg", (register) => {
    console.log(register)
    let user = register.user
    let ip = register.ipAddress
    let addy = register.wallet
    let pic = register.pic
    let file = {}

    file.name = "mywallet"
    file.data = JSON.stringify(wallet)

    filehandler(file)
    let userData = registry.register(user, ip, addy, pic)

    console.log("USERDATA....", userData)
    file.name = "userData"
    file.data = JSON.stringify(userData)
    filehandler(file)

    file.name = "registry"
    file.data = JSON.stringify(registry)
    filehandler(file)
    let regis = registry
    socket.emit("newUser", regis)

  })
  socket.on("chain", (chain) => {
    let file = {}
    file.name = "chain"
    file.data = JSON.stringify(blockchain)

    console.log('recieved chain   SERVER')
    blockchain.replaceChain(chain)
    filehandler(file)
  })
  io.on('tx', (transaction) => {

    console.log("<<<<<<<<<<<GOT TX>>>>>>>>>>>>>")
    transactionPool.updateOrAddTransaction(transaction)

  })
  socket.on("messnum", (num) => {

    if (num > messnum) { messnum = num, console.log("messnum updated :", messnum), socket.emit("messnum", messnum) }
    console.log(messnum)
  })


async function doaMine(){
                if (mining){
                let bubble = abubble
            miner.mine(bubble)
            mining= false
             const bubba= await  doaMine()
               return bubba
                }
                }



  socket.on('newBubble', (bubble) => {
socket.emit('newBubble',bubble)

	for (let peer of peers){

		peer.client.emit('newBubble', bubble)
		console.log ("sent bubble", bubble)
	}
 

    console.log("got new bubble", bubble.name)


    messnum++
    console.log("getting number")
    bubble.time = Date.now()

    foam = {
      "user": bubble.name,
      "bubble": bubble.bubble,
      "sent": bubble.time,
      "num": messnum

    }

  abubble.newBubble(bubble, messnum)

    socket.emit("foaming", foam)
    console.log(foam)
    bubbles += [foam]

    io.emit("messnum", messnum)
  })

socket.on("BEGIN",(begin)=>{
 if (beginTime< 0){
beginTime=begin
console.log("Begin time" , begin)

 }

})

  socket.on('sndTx', function addtx(bubtx) {
    console.dir(`${bubtx[0]}`)
    const amount = parseInt(`${bubtx[0]}`)
    const recipient = `${bubtx[1]}`
    const transaction = wallet.createTransaction(recipient, amount, blockchain, transactionPool);


    console.log('here is your transaction  :', transaction)
    io.emit('broadcastTransaction', transaction)
    io.emit('sxtx',{ type: 'success', transaction });
   
	for (let peer of peers){

	peer.client.emit("tx", transaction)
	}
    socket.emit("tx", transaction)

    io.emit("wallet", { "address": wallet.publicKey, "balance": wallet.calculateBalance(blockchain), "block": blockchain.chain.length })

  })



  socket.on('doMining', () => {
    mining = true
    console.log('mining engaged')
   doaMine()
   

   // socket.emit("chain", blockchain.chain)
mining = false
    let file = {}
    file.name = "chain"
    file.data = JSON.stringify(blockchain)

    filehandler(file)

  })


  socket.on('goodmine', (block) => {
    if (beginTime<0){
      beginTime=Date.now()
      socket.emit("BEGIN",beginTime)
      io.emit("BEGIN",beginTime)
      for (let peer of peers){

        peer.client.emit("BEGIN",beginTime)
           }
    }
	shortest= JSON.stringify(block).length
    io.emit("huffThisBlock", (block))
    console.log("mining", block)

socket.emit()

  })



  
  socket.on("challenger",(challenger)=>{

      console.log("new CHALLENGER" , challenger)
  let myTxt = ''
    let ar2=[]
    let ar1=[]
    let ar3=[]
    let ar4=[]
    let ar5=[]
  //lets create our input from the block and our shared text
//our seed text
//create arrays from texts


for (var i = 0; i < text1.length; i++) {
  let estrings= text1.charCodeAt(i)

     ar1.push(estrings)  //our array of 8 bit  decimal values
}
for (var i = 0; i < text2.length; i++) {
 let estrings= text2.charCodeAt(i)

     ar2.push(estrings)  //our array of 8 bit  decimal values
}

for (var i = 0; i < text3.length; i++) {
let estrings= text3.charCodeAt(i)

   ar3.push(estrings)  //our array of 8 bit  decimal values
}


for (var i = 0; i < text4.length; i++) {
let estrings= text4.charCodeAt(i)

   ar4.push(estrings)  //our array of 8 bit  decimal values
}

for (var i = 0; i < text5.length; i++) {
let estrings= text5.charCodeAt(i)

   ar5.push(estrings)  //our array of 8 bit  decimal values
}
       
// lets re-create our input 
	
    
      
		  let v1 = challenger.v1
		      	let v2 = challenger.v2
		        	let v3 = challenger.v3
		          	let v4 = challenger.v4
		 		          let blurray2=[]
 			          let blurray=[]
  		      	let blurray3=[]
  			       let blurray4=[]
			          	let blurray5=[]
                  myTxt=`[{"amount":420,"address":"04574dc615ac4864b446b32e1e51133ba28f5abe71fe51501fde9a25d247fe169a633ff685f8a841cb78ec5c9127e52fb533e0effddba849b83e92d4434620fa75"}]}],"nonce":223,"difficulty":2,"bubbles":[{"u":"Spayse","n":1}]},{"timestamp":1619021121282,"lastHash":"009c1c8de8e2bf38c12c6cafc9f53e293ae8bf4ba55e8d494b546d1940a272635dfdf2c32769ca96","hash":"000df63de5b23c7a8fb22e6dee69850633624f121f32e355f56321e2d2bc912c00a58ec8714f72a6","data":[{"id":"5f935fd0-a2bb-11eb-840e-517d3b283763","input":{"timestamp":1619021121101,"amount":0,"address":"04e18a0f551bdf457852848c53ef0368f05aa20b6fa7a23b09dce924f10ca60ad999b93017d095d9f755b38b70f8d991b396e6f4f7cc4a23825c309330f8727298","signature":{"r":"578eb3fe69325281ba1d11f5065903385e2195d78fe3362755960e45ad81b0ee","s":"7ad8c9ac53fae1aaed30255b6e90248e79564ab30f29dfebf34cf14d2b81fb9","recoveryParam":1}},"outputs":[{"amount":420,"address":"04574dc615ac4864b446bffffffffffffffffffffffffffdfffffffffffffffffddddddddddddddddddddddddddddd4eeeeeeeee43343400000000000000000000000000000000000000000111111111fbbbbhbbbbbbbbbbbbbbbbbbb32e1e51133ba28f5abe71fe51501fde9a25d247fe169a633ff685f8a841cb78ec5c9127e52fb533e0effddba849b83e92d4434620fa75"}]}],"nonce":3379,"difficulty":3,"bubbles":[]},{"timestamp":1619021650150,"lastHash":"000df63de5b23c7a8fb22e6dee69850633624f121f32e355f56321e2d2bc912c00a58ec8714f72a6"}]`
  
                  for (let i = 0; i<ar1.length; i++ ){
                    let slidx=challenger.v1
                  let n = lerp(ar1[i],ar4[i],slidx)
                  blurray.push(n)
                  
                  
                  }
                  
                  for (let i = 0; i<ar2.length; i++ ){
                    let slidx=challenger.v2
                    let n = lerp(ar2[i],ar3[i],slidx)
                    blurray2.push(n)
                    
                    }
                  
                  
                   for (let i = 0; i<blurray.length; i++ ){
                      let slidx=challenger.v3
                      let n = lerp(blurray2[i],blurray[i],slidx)
                        blurray3.push(n)
                      }
                  
                   for (let i = 0; i<blurray.length; i++ ){
                      let slidx=challenger.v4
                      let n = lerp(blurray2[i],blurray3[i],slidx)
                        blurray5.push(n)
                      }
                  
                  
                   for (let i = 0; i<ar5.length; i++ ){
                      let slidx=challenger.v3
                      let n = lerp(blurray5[i],blurray[i],slidx)
                        blurray4.push(n)
                      }
                   
                  
                     
                   for (let i = 0; i<blurray2.length; i++ ){
                      let slidx=challenger.v4
                      let n = lerp(blurray4[i],blurray3[i],slidx)
                      myTxt+=String.fromCharCode(n)     
                     }
                  
                  
				//strip the block from the chain 
			let pBlock=challenger.huff
     let huffman = Huffman.treeFromText(myTxt)
    let encoded = huffman.encode(JSON.stringify(pBlock))
     ///////////////////////////////////
   console.log( "the encoded text", `${encoded}`)
  let cLength =encoded.length
	if (cLength<shortest){
  

//console.log ("the hew huff :", newhuff)

challenger.huff=encoded
    shortest=cLength
    //console.log ("challenger  :",challenger)
       tempChain =blockchain.addBlock(challenger)
           console.log("your length",cLength)

    
        
          //blockchain.replaceChain(blockchain.chain)

    
             for (let peer of peers){

              peer.client.emit("newChain",tempChain)
                 }
             socket.emit("newchain", tempChain)
             io.emit("newchain", tempChain)
                 
           updateUi

           socket.emit("shorter",shortest)
       console.log( "YOU ARE NOW THE SHORTEST || your size : ",cLength)
      }else{

         console.log(" sorry, you are not the shortest. BLOCK REJECTED -- Your size:",cLength )
       }

    } )


//socket.on ("shorter", (sh)=> {shortest= sh})

    socket.on("newChain", (newChain)=>{
      console.log("newChainMessage", newChain)

      let block=newChain[newChain.length-1]
      let bLength= JSON.stringify(block.huff).length

       game =new Game(newChain,beginTime,shortest)
      let outKum

      if (bLength<shortest){
         

         outKum=game.outcome

        console.log( "outcome",outKum)
      }

          if (outKum){
            console.log("time :", checkTime())           
            tempChain= newChain
            leader = newChain.finder
    let gameObject={}

   
         

          }
          if(checkTime()<0){beginTime=0.1}

          io.on("BEGIN",(begin)=>{
            if (beginTime<0){
            beginTime=begin
            }
          
          })
          
        
if (beginTime>0&&tempChain&&checkTime()<=0){beginTime=-0.1;
  console.log("replacing chain with new chain , winner", tempChain.finder)
   blockchain.replaceChain(tempChain)

   io.emit("WINNER",tempChain.finder)
  }

    })




    
  })
let blokka = []

async function readFile(file) {
  try {
    let rdr = JSON.stringify(fs.readFile(file)) 
    // rdr=rdr.toString()
    //rdr=JSON.parse(rdr)

    blokka.push(rdr.toString())

    // console.log("here is ab array of blocks i hope" +blokka)
    return blokka

  } catch (error) {
    console.error(`Got an error trying to read the file: ${error.message}`);
  }
}

//console.log(blockchain)
//console.log(b(locks)
//peersock.on( 'newTx' ,(transaction)=>{ transactionPool.updateOrAddTransaction(transaction) })

////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////
function broadGame(){
  let t = JSON.stringify(checkTime()).substring(0,5)/1000
  let sh = shortest
  let l = leader

  gameObject={
      "time":t,
  "shortest":sh,
    "leader":l
  }
}

if (checkTime()>0){
  broadGame()
  console.log("Begin :",beginTime)
  setInterval(console.log("Time Left  :",checkTime()), 300)

 
console.log(broadGame().gameObject)
io.emit("theGame",broadGame().gameObject)
  }



setInterval(broadGame,300 )



if (beginTime>0&&tempChain&&checkTime()<=0){beginTime=-0.1;
  console.log("replacing chain with new chain , winner", tempChain.finder)
   blockchain.replaceChain(tempChain)

   io.emit("WINNER",tempChain.finder)
  }
let wrtr = require('fs');
const { networkInterfaces } = require('os')


var bubtimer = (function () {
  var P = [".", "o", "O", "0", "O", "o", ". .", "o   .", "O  .", "0", "O", "o", "."];
  var x = 9;
  return setInterval(function () {
    process.stdout.write("\r" + P[x++]);
    x &= 7;
  }, 190);
})();


function filehandler(file) {
  //reader.readFileSync("public/files/"+`${content}`)

  let data = JSON.stringify(file.data)
  wrtr.writeFileSync(__dirname + '/public/files/' + file.name + '.json', file.data)
  if (console.error()) { console.log('There has been an error saving your configuration data.'), console.log(err.message) } else { console.log('file saved successfully to the following location:  /public/files/ ' + `${file.name}` + '.json') }

}

if(checkTime()<0){beginTime=0.1}

io.on("BEGIN",(begin)=>{
  if (beginTime<0){
  beginTime=begin
  }

})
